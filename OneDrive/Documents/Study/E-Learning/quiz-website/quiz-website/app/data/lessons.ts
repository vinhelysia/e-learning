export interface Question {
  question: string
  options: string[]
  correctAnswer: string
  explanation?: string
  difficulty: "Dễ" | "Trung bình" | "Khó"
}

export interface Lesson {
  id: number
  title: string
  description: string
  topics: string[]
  questions: Question[]
}

export const lessons: Lesson[] = [
  {
    id: 1,
    title: "Tổng quan",
    description: "Khái niệm kỹ thuật lập trình và chu trình phát triển phần mềm",
    topics: [
      "Khái niệm kỹ thuật lập trình",
      "Tổng quan về lập trình",
      "Mô thức lập trình",
      "Chu trình phát triển phần mềm",
    ],
    questions: [
      {
        question: "Kỹ thuật lập trình là gì?",
        options: [
          "Kỹ thuật thực thi một giải pháp phần mềm dựa trên phương pháp luận và ngôn ngữ lập trình",
          "Chỉ là việc viết code bằng ngôn ngữ lập trình",
          "Quá trình thiết kế giao diện người dùng",
          "Kỹ thuật quản lý dự án phần mềm",
        ],
        correctAnswer: "Kỹ thuật thực thi một giải pháp phần mềm dựa trên phương pháp luận và ngôn ngữ lập trình",
        difficulty: "Dễ",
      },
      {
        question: "Mô thức lập trình hướng mệnh lệnh có đặc điểm gì?",
        options: [
          "first do this and next do that",
          "evaluate an expression and use the resulting value",
          "answer a question via searching for a solution",
          "send messages between objects",
        ],
        correctAnswer: "first do this and next do that",
        difficulty: "Trung bình",
      },
      {
        question: "Bước đầu tiên trong chu trình phát triển phần mềm là gì?",
        options: ["Thiết kế giải pháp", "Phân tích yêu cầu", "Cài đặt thiết kế", "Kiểm thử giải pháp"],
        correctAnswer: "Phân tích yêu cầu",
        difficulty: "Dễ",
      },
      {
        question: "Ngôn ngữ lập trình bậc cao có đặc điểm nào?",
        options: [
          "Dựa trên phần cứng (machine-oriented)",
          "Dựa trên vấn đề (problem-oriented) và gần gũi với ngôn ngữ tự nhiên",
          "Chỉ sử dụng số nhị phân",
          "Chỉ có thể chạy trên một loại máy tính",
        ],
        correctAnswer: "Dựa trên vấn đề (problem-oriented) và gần gũi với ngôn ngữ tự nhiên",
        difficulty: "Trung bình",
      },
      {
        question: "Mô thức lập trình hướng đối tượng có đặc điểm chính là gì?",
        options: [
          "Sử dụng các hàm toán học",
          "Gửi thông điệp giữa các đối tượng để mô phỏng thế giới thực",
          "Thực hiện tuần tự các lệnh",
          "Tìm kiếm lời giải thông qua suy luận logic",
        ],
        correctAnswer: "Gửi thông điệp giữa các đối tượng để mô phỏng thế giới thực",
        difficulty: "Trung bình",
      },
      {
        question: "Các thành phần cơ bản của ngôn ngữ lập trình bao gồm:",
        options: ["Mô thức, Cú pháp, Ngữ nghĩa", "Chỉ có Cú pháp", "Chỉ có Ngữ nghĩa", "Chỉ có Mô thức"],
        correctAnswer: "Mô thức, Cú pháp, Ngữ nghĩa",
        difficulty: "Trung bình",
      },
      {
        question: "Trình dịch (compiler) khác với thông dịch (interpreter) như thế nào?",
        options: [
          "Compiler dịch toàn bộ chương trình trước khi thực hiện, interpreter dịch và thực hiện từng dòng",
          "Không có sự khác biệt",
          "Interpreter nhanh hơn compiler",
          "Compiler chỉ dùng cho C++",
        ],
        correctAnswer:
          "Compiler dịch toàn bộ chương trình trước khi thực hiện, interpreter dịch và thực hiện từng dòng",
        difficulty: "Trung bình",
      },
      {
        question: "Bước 'Chứng thực thiết kế' trong chu trình phát triển phần mềm bao gồm:",
        options: [
          "Viết code",
          "Kiểm tra độ chính xác bằng cách tìm logic error và sử dụng test data",
          "Phân tích yêu cầu",
          "Viết tài liệu",
        ],
        correctAnswer: "Kiểm tra độ chính xác bằng cách tìm logic error và sử dụng test data",
        difficulty: "Trung bình",
      },
      {
        question: "Cấu trúc lặp trong lập trình có tác dụng gì?",
        options: [
          "Thực hiện lặp đi lặp lại một hoặc nhiều lệnh cho đến khi thỏa mãn điều kiện",
          "Chỉ thực hiện một lần",
          "Chỉ dùng cho vòng lặp for",
          "Không có tác dụng gì",
        ],
        correctAnswer: "Thực hiện lặp đi lặp lại một hoặc nhiều lệnh cho đến khi thỏa mãn điều kiện",
        difficulty: "Dễ",
      },
      {
        question: "Mô thức lập trình hướng logic có đặc điểm:",
        options: [
          "Dựa trên các tiên đề, quy luật suy diễn và truy vấn",
          "Chỉ sử dụng hàm số",
          "Chỉ sử dụng đối tượng",
          "Chỉ sử dụng mệnh lệnh",
        ],
        correctAnswer: "Dựa trên các tiên đề, quy luật suy diễn và truy vấn",
        difficulty: "Khó",
      },
      {
        question: "IPO chart trong thiết kế có nghĩa là gì?",
        options: [
          "Input - Process - Output",
          "Interface - Program - Object",
          "Integer - Pointer - Operation",
          "Import - Print - Open",
        ],
        correctAnswer: "Input - Process - Output",
        difficulty: "Dễ",
      },
      {
        question: "Structured design còn được gọi là:",
        options: ["Bottom-up design", "Top-down design", "Random design", "Object design"],
        correctAnswer: "Top-down design",
        difficulty: "Trung bình",
      },
      {
        question: "Bước cuối cùng trong chu trình phát triển phần mềm là:",
        options: ["Kiểm thử giải pháp", "Cài đặt thiết kế", "Viết tài liệu cho giải pháp", "Phân tích yêu cầu"],
        correctAnswer: "Viết tài liệu cho giải pháp",
        difficulty: "Dễ",
      },
    ],
  },
  {
    id: 2,
    title: "C/C++ nâng cao",
    description: "Con trỏ, quản lý bộ nhớ, hàm và đa năng hóa",
    topics: ["Con trỏ (Pointer)", "Quản lý bộ nhớ", "Hàm và tham số", "Đa năng hóa (Overloading)"],
    questions: [
      {
        question: "Con trỏ trong C/C++ là gì?",
        options: [
          "Một biến mà nội dung của nó là địa chỉ của một đối tượng khác",
          "Một hàm đặc biệt",
          "Một kiểu dữ liệu cơ bản",
          "Một cấu trúc dữ liệu",
        ],
        correctAnswer: "Một biến mà nội dung của nó là địa chỉ của một đối tượng khác",
        difficulty: "Dễ",
      },
      {
        question: "Toán tử nào được dùng để lấy địa chỉ của một biến?",
        options: ["*", "&", "->", "%"],
        correctAnswer: "&",
        difficulty: "Dễ",
      },
      {
        question: "Trong C++, từ khóa 'new' được dùng để làm gì?",
        options: ["Khai báo biến mới", "Xin cấp phát bộ nhớ động", "Tạo hàm mới", "Định nghĩa lớp mới"],
        correctAnswer: "Xin cấp phát bộ nhớ động",
        difficulty: "Trung bình",
      },
      {
        question: "Đa năng hóa hàm (Function Overloading) cho phép:",
        options: [
          "Một hàm có nhiều tên khác nhau",
          "Nhiều hàm có cùng tên nhưng khác tham số",
          "Hàm có thể trả về nhiều kiểu dữ liệu",
          "Hàm có thể được gọi nhiều lần",
        ],
        correctAnswer: "Nhiều hàm có cùng tên nhưng khác tham số",
        difficulty: "Trung bình",
      },
      {
        question: "Con trỏ void* có đặc điểm gì?",
        options: [
          "Chỉ có thể trỏ tới biến kiểu int",
          "Là con trỏ không định kiểu, có thể trỏ tới bất kì loại biến nào",
          "Chỉ có thể trỏ tới hàm",
          "Không thể sử dụng trong C++",
        ],
        correctAnswer: "Là con trỏ không định kiểu, có thể trỏ tới bất kì loại biến nào",
        difficulty: "Khó",
      },
      {
        question: "Mảng các con trỏ khác với mảng nhiều chiều như thế nào?",
        options: [
          "Mảng con trỏ chỉ dành không gian cho các biến trỏ, mảng nhiều chiều có đủ vùng nhớ cho các phần tử",
          "Không có sự khác biệt",
          "Mảng nhiều chiều nhanh hơn",
          "Mảng con trỏ không thể sử dụng",
        ],
        correctAnswer:
          "Mảng con trỏ chỉ dành không gian cho các biến trỏ, mảng nhiều chiều có đủ vùng nhớ cho các phần tử",
        difficulty: "Khó",
      },
      {
        question: "Trong C++, từ khóa 'delete' được dùng để:",
        options: ["Xóa file", "Giải phóng bộ nhớ động", "Xóa biến", "Xóa hàm"],
        correctAnswer: "Giải phóng bộ nhớ động",
        difficulty: "Dễ",
      },
      {
        question: "Tham số mặc định (default parameter) trong C++ có đặc điểm:",
        options: [
          "Phải là tham số đầu tiên",
          "Phải được nhóm lại và ở cuối danh sách tham số",
          "Có thể ở bất kỳ vị trí nào",
          "Không thể sử dụng",
        ],
        correctAnswer: "Phải được nhóm lại và ở cuối danh sách tham số",
        difficulty: "Trung bình",
      },
      {
        question: "Phép tham chiếu (reference) trong C++ khác với con trỏ như thế nào?",
        options: [
          "Reference phải được khởi tạo khi khai báo và không thể thay đổi",
          "Reference giống hệt con trỏ",
          "Reference chậm hơn con trỏ",
          "Reference không thể sử dụng",
        ],
        correctAnswer: "Reference phải được khởi tạo khi khai báo và không thể thay đổi",
        difficulty: "Khó",
      },
      {
        question: "Đa năng hóa toán tử (operator overloading) không thể áp dụng cho:",
        options: ["Toán tử +, -, *, /", "Toán tử ::, .*, ., ?:", "Toán tử ==, !=", "Toán tử [], ()"],
        correctAnswer: "Toán tử ::, .*, ., ?:",
        difficulty: "Khó",
      },
      {
        question: "Con trỏ trỏ tới con trỏ được khai báo như thế nào?",
        options: ["int *p;", "int **p;", "int ***p;", "int &p;"],
        correctAnswer: "int **p;",
        difficulty: "Trung bình",
      },
      {
        question: "Khi nào nên sử dụng malloc() thay vì new?",
        options: [
          "Trong C++, nên dùng new",
          "Trong C, phải dùng malloc()",
          "Không có sự khác biệt",
          "Tùy thuộc vào kích thước bộ nhớ",
        ],
        correctAnswer: "Trong C, phải dùng malloc()",
        difficulty: "Trung bình",
      },
      {
        question: "Inline function có ưu điểm gì?",
        options: [
          "Tăng kích thước chương trình nhưng nhanh hơn (không dùng stack)",
          "Giảm kích thước chương trình",
          "Chậm hơn hàm thường",
          "Không có ưu điểm",
        ],
        correctAnswer: "Tăng kích thước chương trình nhưng nhanh hơn (không dùng stack)",
        difficulty: "Trung bình",
      },
    ],
  },
  {
    id: 3,
    title: "Giải thuật",
    description: "Tìm kiếm, sắp xếp và đệ quy",
    topics: ["Tìm kiếm (Search)", "Sắp xếp (Sort)", "Đệ quy (Recursive)"],
    questions: [
      {
        question: "Giải thuật là gì?",
        options: [
          "Một chương trình máy tính",
          "Một tập các chỉ lệnh để thực hiện một tác vụ nhất định",
          "Một ngôn ngữ lập trình",
          "Một cấu trúc dữ liệu",
        ],
        correctAnswer: "Một tập các chỉ lệnh để thực hiện một tác vụ nhất định",
        difficulty: "Dễ",
      },
      {
        question: "Tìm kiếm nhị phân yêu cầu điều kiện gì?",
        options: [
          "Dữ liệu phải được sắp xếp theo thứ tự",
          "Dữ liệu phải là số nguyên",
          "Dữ liệu phải có kích thước nhỏ",
          "Không có điều kiện đặc biệt",
        ],
        correctAnswer: "Dữ liệu phải được sắp xếp theo thứ tự",
        difficulty: "Trung bình",
      },
      {
        question: "Đệ quy có những thành phần nào?",
        options: [
          "Chỉ có phần gọi đệ quy",
          "Phần neo (base case) và phần quy nạp (recursive case)",
          "Chỉ có phần neo",
          "Phần khởi tạo và phần kết thúc",
        ],
        correctAnswer: "Phần neo (base case) và phần quy nạp (recursive case)",
        difficulty: "Trung bình",
      },
      {
        question: "Bài toán Tháp Hà Nội với n đĩa cần bao nhiêu lần chuyển?",
        options: ["n", "n²", "2ⁿ - 1", "n!"],
        correctAnswer: "2ⁿ - 1",
        difficulty: "Khó",
      },
      {
        question: "Đệ quy tuyến tính có đặc điểm gì?",
        options: [
          "Có nhiều lời gọi đệ quy trong một hàm",
          "Chỉ có một lời gọi đệ quy trong một hàm",
          "Không có điều kiện dừng",
          "Chỉ xử lý dữ liệu số",
        ],
        correctAnswer: "Chỉ có một lời gọi đệ quy trong một hàm",
        difficulty: "Trung bình",
      },
      {
        question: "Độ phức tạp của thuật toán tìm kiếm tuần tự là:",
        options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
        correctAnswer: "O(n)",
        difficulty: "Trung bình",
      },
      {
        question: "Độ phức tạp của thuật toán tìm kiếm nhị phân là:",
        options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
        correctAnswer: "O(log n)",
        difficulty: "Trung bình",
      },
      {
        question: "Đệ quy nhị phân có đặc điểm:",
        options: [
          "Có một lời gọi đệ quy",
          "Có hai lời gọi đệ quy",
          "Không có lời gọi đệ quy",
          "Có nhiều lời gọi đệ quy trong vòng lặp",
        ],
        correctAnswer: "Có hai lời gọi đệ quy",
        difficulty: "Trung bình",
      },
      {
        question: "Đệ quy phi tuyến có đặc điểm:",
        options: [
          "Lời gọi đệ quy được thực hiện bên trong vòng lặp",
          "Chỉ có một lời gọi đệ quy",
          "Không có vòng lặp",
          "Chỉ xử lý số nguyên",
        ],
        correctAnswer: "Lời gọi đệ quy được thực hiện bên trong vòng lặp",
        difficulty: "Khó",
      },
      {
        question: "Đệ quy tương hỗ là:",
        options: ["Một hàm gọi chính nó", "Hai hàm gọi lẫn nhau", "Nhiều hàm gọi cùng lúc", "Không có lời gọi hàm"],
        correctAnswer: "Hai hàm gọi lẫn nhau",
        difficulty: "Khó",
      },
      {
        question: "Khử đệ quy bằng vòng lặp áp dụng cho:",
        options: [
          "Tất cả các dạng đệ quy",
          "Đệ quy tuyến tính dạng f(n) = g(n, f(n-1))",
          "Chỉ đệ quy nhị phân",
          "Chỉ đệ quy phi tuyến",
        ],
        correctAnswer: "Đệ quy tuyến tính dạng f(n) = g(n, f(n-1))",
        difficulty: "Khó",
      },
      {
        question: "Khử đệ quy bằng stack được sử dụng khi:",
        options: [
          "Đệ quy đơn giản",
          "Đệ quy phức tạp không thể khử bằng vòng lặp",
          "Không bao giờ",
          "Chỉ với đệ quy tuyến tính",
        ],
        correctAnswer: "Đệ quy phức tạp không thể khử bằng vòng lặp",
        difficulty: "Khó",
      },
      {
        question: "Bài toán chia phần thưởng sử dụng đệ quy nào?",
        options: ["Đệ quy tuyến tính", "Đệ quy nhị phân", "Đệ quy phi tuyến", "Đệ quy tương hỗ"],
        correctAnswer: "Đệ quy nhị phân",
        difficulty: "Khó",
      },
    ],
  },
  {
    id: 4,
    title: "Cấu trúc dữ liệu",
    description: "Mảng, danh sách, ngăn xếp, hàng đợi và cây",
    topics: ["Mảng (Array)", "Danh sách (List)", "Ngăn xếp (Stack)", "Hàng đợi (Queue)", "Cây (Tree)"],
    questions: [
      {
        question: "Cấu trúc dữ liệu là gì?",
        options: [
          "Chỉ là cách lưu trữ dữ liệu",
          "Cách tổ chức và thao tác có hệ thống trên dữ liệu",
          "Một ngôn ngữ lập trình",
          "Một thuật toán",
        ],
        correctAnswer: "Cách tổ chức và thao tác có hệ thống trên dữ liệu",
        difficulty: "Dễ",
      },
      {
        question: "Ngăn xếp (Stack) hoạt động theo nguyên tắc nào?",
        options: ["FIFO (First In First Out)", "LIFO (Last In First Out)", "Random access", "Sequential access"],
        correctAnswer: "LIFO (Last In First Out)",
        difficulty: "Dễ",
      },
      {
        question: "Hàng đợi (Queue) hoạt động theo nguyên tắc nào?",
        options: ["LIFO (Last In First Out)", "FIFO (First In First Out)", "Random access", "Binary search"],
        correctAnswer: "FIFO (First In First Out)",
        difficulty: "Dễ",
      },
      {
        question: "Trong cây nhị phân, mỗi nút có tối đa bao nhiêu nút con?",
        options: ["1", "2", "3", "Không giới hạn"],
        correctAnswer: "2",
        difficulty: "Dễ",
      },
      {
        question: "Danh sách liên kết có ưu điểm gì so với mảng?",
        options: [
          "Truy cập ngẫu nhiên nhanh hơn",
          "Kích thước linh động, thêm/xóa dễ dàng",
          "Sử dụng ít bộ nhớ hơn",
          "Luôn được sắp xếp",
        ],
        correctAnswer: "Kích thước linh động, thêm/xóa dễ dàng",
        difficulty: "Trung bình",
      },
      {
        question: "Duyệt cây theo thứ tự giữa (Inorder) có thứ tự nào?",
        options: ["Gốc -> Trái -> Phải", "Trái -> Gốc -> Phải", "Trái -> Phải -> Gốc", "Phải -> Gốc -> Trái"],
        correctAnswer: "Trái -> Gốc -> Phải",
        difficulty: "Trung bình",
      },
      {
        question: "Ưu điểm của danh sách kế tiếp so với danh sách mốc nối:",
        options: ["Tốc độ truy cập nhanh", "Kích thước linh động", "Dễ thêm/xóa phần tử", "Tiết kiệm bộ nhớ"],
        correctAnswer: "Tốc độ truy cập nhanh",
        difficulty: "Trung bình",
      },
      {
        question: "Nhược điểm của danh sách kế tiếp:",
        options: [
          "Truy cập chậm",
          "Cần biết trước kích thước tối đa và thao tác thêm/xóa tốn kém",
          "Khó cài đặt",
          "Không thể sắp xếp",
        ],
        correctAnswer: "Cần biết trước kích thước tối đa và thao tác thêm/xóa tốn kém",
        difficulty: "Trung bình",
      },
      {
        question: "Danh sách nối kép có ưu điểm gì so với danh sách nối đơn?",
        options: [
          "Tiết kiệm bộ nhớ hơn",
          "Có thể duyệt theo chiều ngược lại và dễ dàng truy cập nút trước",
          "Nhanh hơn",
          "Đơn giản hơn",
        ],
        correctAnswer: "Có thể duyệt theo chiều ngược lại và dễ dàng truy cập nút trước",
        difficulty: "Trung bình",
      },
      {
        question: "Ứng dụng của ngăn xếp trong bài toán đổi cơ số:",
        options: [
          "Lưu trữ kết quả cuối cùng",
          "Lưu trữ các chữ số theo thứ tự ngược để in ra đúng thứ tự",
          "Tính toán nhanh hơn",
          "Tiết kiệm bộ nhớ",
        ],
        correctAnswer: "Lưu trữ các chữ số theo thứ tự ngược để in ra đúng thứ tự",
        difficulty: "Trung bình",
      },
      {
        question: "Ký pháp hậu tố có ưu điểm gì?",
        options: ["Dễ đọc hơn", "Không cần dấu ngoặc và dễ tính toán bằng stack", "Ngắn gọn hơn", "Phổ biến hơn"],
        correctAnswer: "Không cần dấu ngoặc và dễ tính toán bằng stack",
        difficulty: "Trung bình",
      },
      {
        question: "Hàng đợi vòng (circular queue) giải quyết vấn đề gì?",
        options: [
          "Tăng tốc độ",
          "Tránh lãng phí bộ nhớ khi front và rear chỉ tăng",
          "Giảm độ phức tạp",
          "Tăng kích thước",
        ],
        correctAnswer: "Tránh lãng phí bộ nhớ khi front và rear chỉ tăng",
        difficulty: "Khó",
      },
      {
        question: "Cây nhị phân đầy đủ có đặc điểm:",
        options: [
          "Tất cả nút lá có cùng độ sâu",
          "Tất cả nút trừ nút lá có cấp bằng 2",
          "Có đúng 2 nút con",
          "Không có nút lá",
        ],
        correctAnswer: "Tất cả nút trừ nút lá có cấp bằng 2",
        difficulty: "Trung bình",
      },
      {
        question: "Duyệt cây theo thứ tự trước (Preorder) có thứ tự:",
        options: ["Trái -> Gốc -> Phải", "Gốc -> Trái -> Phải", "Trái -> Phải -> Gốc", "Phải -> Gốc -> Trái"],
        correctAnswer: "Gốc -> Trái -> Phải",
        difficulty: "Dễ",
      },
      {
        question: "Cây biểu diễn biểu thức có đặc điểm:",
        options: [
          "Nút lá chứa toán tử, nút giữa chứa toán hạng",
          "Nút lá chứa toán hạng, nút giữa chứa toán tử",
          "Tất cả nút đều chứa toán tử",
          "Tất cả nút đều chứa toán hạng",
        ],
        correctAnswer: "Nút lá chứa toán hạng, nút giữa chứa toán tử",
        difficulty: "Trung bình",
      },
    ],
  },
  {
    id: 5,
    title: "Thiết kế chương trình",
    description: "Nguyên tắc chung và thiết kế giải thuật, dữ liệu",
    topics: ["Nguyên tắc chung", "Thiết kế giải thuật", "Thiết kế dữ liệu"],
    questions: [
      {
        question: "Phẩm chất của một chương trình tốt bao gồm:",
        options: [
          "Chỉ cần chạy được",
          "Cấu trúc tốt, logic rõ ràng, tên miêu tả, chú thích hợp lý",
          "Chỉ cần nhanh",
          "Chỉ cần ít dòng code",
        ],
        correctAnswer: "Cấu trúc tốt, logic rõ ràng, tên miêu tả, chú thích hợp lý",
        difficulty: "Dễ",
      },
      {
        question: "Thiết kế top-down là gì?",
        options: [
          "Thiết kế từ chi tiết đến tổng thể",
          "Thiết kế từ tổng thể đến chi tiết, tinh chỉnh từng bước",
          "Thiết kế ngẫu nhiên",
          "Thiết kế theo kinh nghiệm",
        ],
        correctAnswer: "Thiết kế từ tổng thể đến chi tiết, tinh chỉnh từng bước",
        difficulty: "Trung bình",
      },
      {
        question: "Ưu điểm của mô-đun hóa là gì?",
        options: [
          "Làm chương trình phức tạp hơn",
          "Dễ đọc code, dễ test, dễ mở rộng và bảo trì",
          "Tăng kích thước chương trình",
          "Giảm hiệu suất",
        ],
        correctAnswer: "Dễ đọc code, dễ test, dễ mở rộng và bảo trì",
        difficulty: "Trung bình",
      },
      {
        question: "Nguyên tắc 'Đơn giản' trong thiết kế chương trình có nghĩa là:",
        options: [
          "Viết ít code nhất có thể",
          "Thể hiện giải thuật như nó vốn có, đừng quá kỳ bí",
          "Không cần chú thích",
          "Sử dụng nhiều biến toàn cục",
        ],
        correctAnswer: "Thể hiện giải thuật như nó vốn có, đừng quá kỳ bí",
        difficulty: "Trung bình",
      },
      {
        question: "Thiết kế dữ liệu cần cung cấp những thao tác cơ bản nào?",
        options: [
          "Chỉ cần Create và Delete",
          "Create, Add, Search, Free",
          "Chỉ cần Read và Write",
          "Chỉ cần Sort và Search",
        ],
        correctAnswer: "Create, Add, Search, Free",
        difficulty: "Trung bình",
      },
      {
        question: "Tính trừu tượng (Abstraction) trong thiết kế chương trình là gì?",
        options: [
          "Ẩn các chi tiết không cần thiết và chỉ hiển thị các thông tin quan trọng",
          "Viết code phức tạp",
          "Sử dụng nhiều biến toàn cục",
          "Không sử dụng hàm",
        ],
        correctAnswer: "Ẩn các chi tiết không cần thiết và chỉ hiển thị các thông tin quan trọng",
        difficulty: "Trung bình",
      },
      {
        question: "Tính module hóa (Modularity) giúp chương trình như thế nào?",
        options: ["Khó bảo trì hơn", "Dễ đọc, dễ test và dễ bảo trì", "Tăng kích thước chương trình", "Giảm hiệu suất"],
        correctAnswer: "Dễ đọc, dễ test và dễ bảo trì",
        difficulty: "Trung bình",
      },
      {
        question: "Thiết kế hướng đối tượng tập trung vào điều gì?",
        options: ["Hàm và thủ tục", "Dữ liệu và đối tượng", "Cấu trúc điều khiển", "Thuật toán"],
        correctAnswer: "Dữ liệu và đối tượng",
        difficulty: "Trung bình",
      },
      {
        question: "Nguyên tắc 'Keep it Simple, Stupid' (KISS) có nghĩa là gì?",
        options: [
          "Viết code phức tạp",
          "Giữ cho thiết kế đơn giản và dễ hiểu",
          "Không cần chú thích",
          "Sử dụng nhiều biến toàn cục",
        ],
        correctAnswer: "Giữ cho thiết kế đơn giản và dễ hiểu",
        difficulty: "Trung bình",
      },
      {
        question: "Thiết kế dữ liệu cần quan tâm đến yếu tố nào?",
        options: [
          "Chỉ cần kiểu dữ liệu",
          "Kiểu dữ liệu, cấu trúc và các thao tác trên dữ liệu",
          "Chỉ cần kích thước dữ liệu",
          "Chỉ cần tên biến",
        ],
        correctAnswer: "Kiểu dữ liệu, cấu trúc và các thao tác trên dữ liệu",
        difficulty: "Trung bình",
      },
      {
        question: "Thiết kế giải thuật cần đảm bảo điều gì?",
        options: ["Chỉ cần chạy được", "Đúng đắn, hiệu quả và dễ hiểu", "Chỉ cần nhanh", "Chỉ cần ít dòng code"],
        correctAnswer: "Đúng đắn, hiệu quả và dễ hiểu",
        difficulty: "Trung bình",
      },
      {
        question: "Thiết kế chương trình cần tuân thủ nguyên tắc nào?",
        options: [
          "Chỉ cần chạy được",
          "Rõ ràng, đơn giản, hiệu quả và dễ bảo trì",
          "Chỉ cần nhanh",
          "Chỉ cần ít dòng code",
        ],
        correctAnswer: "Rõ ràng, đơn giản, hiệu quả và dễ bảo trì",
        difficulty: "Trung bình",
      },
      {
        question: "Thiết kế giao diện người dùng cần quan tâm đến yếu tố nào?",
        options: [
          "Chỉ cần đẹp",
          "Dễ sử dụng, thân thiện và hiệu quả",
          "Chỉ cần nhiều màu sắc",
          "Chỉ cần nhiều hiệu ứng",
        ],
        correctAnswer: "Dễ sử dụng, thân thiện và hiệu quả",
        difficulty: "Trung bình",
      },
    ],
  },
  {
    id: 6,
    title: "Phong cách lập trình",
    description: "Cấu trúc mã nguồn, đặt tên và chú thích",
    topics: ["Tổng quan", "Cấu trúc mã nguồn", "Đặt tên và chú thích"],
    questions: [
      {
        question: "Tại sao cần có phong cách lập trình tốt?",
        options: [
          "Để code chạy nhanh hơn",
          "Để mã nguồn dễ đọc và giảm lỗi do nhầm lẫn",
          "Để tiết kiệm bộ nhớ",
          "Để tăng kích thước file",
        ],
        correctAnswer: "Để mã nguồn dễ đọc và giảm lỗi do nhầm lẫn",
        difficulty: "Dễ",
      },
      {
        question: "Quy tắc đặt tên biến tốt là:",
        options: [
          "Dùng tên ngắn nhất có thể",
          "Dùng tên gợi nhớ, có tính miêu tả và nhất quán",
          "Dùng số thay vì chữ",
          "Dùng tên tiếng Anh phức tạp",
        ],
        correctAnswer: "Dùng tên gợi nhớ, có tính miêu tả và nhất quán",
        difficulty: "Dễ",
      },
      {
        question: "Khi nào nên viết chú thích?",
        options: [
          "Chú thích từng dòng code",
          "Chú thích để thêm thông tin, giải thích các đoạn code",
          "Không cần chú thích",
          "Chỉ chú thích khi code sai",
        ],
        correctAnswer: "Chú thích để thêm thông tin, giải thích các đoạn code",
        difficulty: "Trung bình",
      },
      {
        question: "Cách lề (Indentation) có tác dụng gì?",
        options: [
          "Làm đẹp code",
          "Tránh nhầm lẫn về cấu trúc chương trình",
          "Tăng tốc độ chạy",
          "Giảm kích thước file",
        ],
        correctAnswer: "Tránh nhầm lẫn về cấu trúc chương trình",
        difficulty: "Dễ",
      },
      {
        question: "Quy tắc 'Write clearly / don't be too clever' có nghĩa là:",
        options: [
          "Viết code phức tạp để thể hiện trình độ",
          "Viết rõ ràng, đừng quá thông minh (kỳ bí)",
          "Viết nhiều comment",
          "Sử dụng nhiều biến",
        ],
        correctAnswer: "Viết rõ ràng, đừng quá thông minh (kỳ bí)",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần cấu trúc mã nguồn rõ ràng?",
        options: [
          "Để code chạy nhanh hơn",
          "Để dễ đọc, dễ hiểu và dễ bảo trì",
          "Để tiết kiệm bộ nhớ",
          "Để tăng kích thước file",
        ],
        correctAnswer: "Để dễ đọc, dễ hiểu và dễ bảo trì",
        difficulty: "Dễ",
      },
      {
        question: "Quy tắc đặt tên hàm tốt là gì?",
        options: [
          "Dùng tên ngắn nhất có thể",
          "Dùng tên gợi nhớ, có tính miêu tả và nhất quán",
          "Dùng số thay vì chữ",
          "Dùng tên tiếng Anh phức tạp",
        ],
        correctAnswer: "Dùng tên gợi nhớ, có tính miêu tả và nhất quán",
        difficulty: "Dễ",
      },
      {
        question: "Chú thích nên được viết như thế nào?",
        options: [
          "Chú thích từng dòng code",
          "Chú thích để thêm thông tin, giải thích các đoạn code",
          "Không cần chú thích",
          "Chỉ chú thích khi code sai",
        ],
        correctAnswer: "Chú thích để thêm thông tin, giải thích các đoạn code",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần cách lề (Indentation) nhất quán?",
        options: [
          "Làm đẹp code",
          "Tránh nhầm lẫn về cấu trúc chương trình",
          "Tăng tốc độ chạy",
          "Giảm kích thước file",
        ],
        correctAnswer: "Tránh nhầm lẫn về cấu trúc chương trình",
        difficulty: "Dễ",
      },
      {
        question: "Quy tắc 'Keep it simple' có nghĩa là gì?",
        options: ["Viết code phức tạp", "Viết code đơn giản, dễ hiểu", "Viết nhiều comment", "Sử dụng nhiều biến"],
        correctAnswer: "Viết code đơn giản, dễ hiểu",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần tuân thủ coding convention?",
        options: [
          "Để code chạy nhanh hơn",
          "Để code dễ đọc, dễ hiểu và dễ bảo trì",
          "Để tiết kiệm bộ nhớ",
          "Để tăng kích thước file",
        ],
        correctAnswer: "Để code dễ đọc, dễ hiểu và dễ bảo trì",
        difficulty: "Trung bình",
      },
      {
        question: "Khi nào nên sử dụng comment block?",
        options: [
          "Comment từng dòng code",
          "Giải thích các đoạn code phức tạp, các hàm, các class",
          "Không cần comment",
          "Chỉ comment khi code sai",
        ],
        correctAnswer: "Giải thích các đoạn code phức tạp, các hàm, các class",
        difficulty: "Trung bình",
      },
    ],
  },
  {
    id: 7,
    title: "Tăng hiệu năng chương trình",
    description: "Các nguyên lý cơ bản và kỹ thuật tối ưu hóa",
    topics: ["Tổng quan", "Các nguyên lý cơ bản", "Kỹ thuật tăng hiệu năng", "Tinh chỉnh mã nguồn"],
    questions: [
      {
        question: "Cách tốt nhất để tăng hiệu năng chương trình là:",
        options: [
          "Dùng giải thuật tốt nhất có thể, sau đó mới nghĩ tới việc tăng tính hiệu quả của code",
          "Chỉ tối ưu code",
          "Chỉ tăng tốc độ CPU",
          "Chỉ tăng RAM",
        ],
        correctAnswer: "Dùng giải thuật tốt nhất có thể, sau đó mới nghĩ tới việc tăng tính hiệu quả của code",
        difficulty: "Trung bình",
      },
      {
        question: "Quy tắc 'Loop rules' bao gồm:",
        options: [
          "Chỉ sử dụng vòng lặp for",
          "Đưa code ra khỏi vòng lặp, kết hợp các vòng lặp, giảm phép kiểm tra",
          "Sử dụng nhiều vòng lặp lồng nhau",
          "Tránh sử dụng vòng lặp",
        ],
        correctAnswer: "Đưa code ra khỏi vòng lặp, kết hợp các vòng lặp, giảm phép kiểm tra",
        difficulty: "Khó",
      },
      {
        question: "Kỹ thuật 'Caching' có tác dụng gì?",
        options: [
          "Xóa dữ liệu không cần thiết",
          "Dữ liệu thường dùng cần phải dễ tiếp cận nhất, luôn hiện hữu",
          "Tăng kích thước chương trình",
          "Giảm tốc độ truy cập",
        ],
        correctAnswer: "Dữ liệu thường dùng cần phải dễ tiếp cận nhất, luôn hiện hữu",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao nên đặt kích thước mảng = 2ⁿ?",
        options: [
          "Để tiết kiệm bộ nhớ",
          "Để phép nhân có thể được chuyển thành phép dịch chuyển nhanh chóng",
          "Để dễ nhớ",
          "Để tăng độ chính xác",
        ],
        correctAnswer: "Để phép nhân có thể được chuyển thành phép dịch chuyển nhanh chóng",
        difficulty: "Khó",
      },
      {
        question: "Khi nào nên tối ưu hóa chương trình?",
        options: [
          "Ngay từ đầu khi viết code",
          "Sau khi chương trình chạy đúng và đủ nhanh thì mới cần quan tâm",
          "Không bao giờ",
          "Chỉ khi có lỗi",
        ],
        correctAnswer: "Sau khi chương trình chạy đúng và đủ nhanh thì mới cần quan tâm",
        difficulty: "Trung bình",
      },
      {
        question: "Nguyên tắc '80-20 rule' trong tối ưu hóa có nghĩa là gì?",
        options: [
          "80% thời gian chạy chương trình nằm trong 20% code",
          "80% code cần được tối ưu, 20% không cần",
          "80% bộ nhớ được sử dụng bởi 20% dữ liệu",
          "Không có ý nghĩa gì",
        ],
        correctAnswer: "80% thời gian chạy chương trình nằm trong 20% code",
        difficulty: "Khó",
      },
      {
        question: "Kỹ thuật 'Strength reduction' là gì?",
        options: [
          "Thay thế các phép toán tốn kém bằng các phép toán rẻ hơn",
          "Giảm kích thước code",
          "Tăng tốc độ CPU",
          "Giảm sử dụng bộ nhớ",
        ],
        correctAnswer: "Thay thế các phép toán tốn kém bằng các phép toán rẻ hơn",
        difficulty: "Khó",
      },
      {
        question: "Kỹ thuật 'Loop unrolling' là gì?",
        options: [
          "Mở rộng vòng lặp để giảm số lần kiểm tra điều kiện",
          "Giảm số lượng vòng lặp",
          "Tăng số lượng vòng lặp",
          "Không có tác dụng gì",
        ],
        correctAnswer: "Mở rộng vòng lặp để giảm số lần kiểm tra điều kiện",
        difficulty: "Khó",
      },
      {
        question: "Tại sao nên sử dụng profiler?",
        options: [
          "Để tìm ra bottleneck của chương trình",
          "Để tăng tốc độ CPU",
          "Để giảm sử dụng bộ nhớ",
          "Để viết code nhanh hơn",
        ],
        correctAnswer: "Để tìm ra bottleneck của chương trình",
        difficulty: "Trung bình",
      },
      {
        question: "Khi nào nên sử dụng inline function?",
        options: [
          "Khi hàm quá lớn",
          "Khi hàm được gọi nhiều lần và nhỏ",
          "Khi hàm chỉ được gọi một lần",
          "Không nên sử dụng",
        ],
        correctAnswer: "Khi hàm được gọi nhiều lần và nhỏ",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao nên tránh sử dụng đệ quy?",
        options: [
          "Đệ quy luôn chậm hơn vòng lặp",
          "Đệ quy tốn nhiều bộ nhớ stack",
          "Đệ quy khó hiểu",
          "Không nên tránh sử dụng đệ quy",
        ],
        correctAnswer: "Đệ quy tốn nhiều bộ nhớ stack",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao nên sử dụng bitwise operation?",
        options: [
          "Bitwise operation luôn nhanh hơn các phép toán khác",
          "Bitwise operation cho phép thao tác trực tiếp trên bit",
          "Bitwise operation dễ hiểu",
          "Không nên sử dụng bitwise operation",
        ],
        correctAnswer: "Bitwise operation cho phép thao tác trực tiếp trên bit",
        difficulty: "Khó",
      },
    ],
  },
  {
    id: 8,
    title: "Lập trình phòng ngừa",
    description: "Phòng ngừa sai sót về dữ liệu, xử lý lỗi và bảo đảm",
    topics: ["Khái niệm", "Phòng ngừa sai sót về dữ liệu", "Xử lý lỗi", "Bảo đảm (Assertion)"],
    questions: [
      {
        question: "Lập trình phòng ngừa (Defensive Programming) là gì?",
        options: [
          "Lập trình để tấn công hệ thống",
          "Tự bảo vệ chương trình khỏi dữ liệu không hợp lệ và các rủi ro",
          "Lập trình game",
          "Lập trình web",
        ],
        correctAnswer: "Tự bảo vệ chương trình khỏi dữ liệu không hợp lệ và các rủi ro",
        difficulty: "Dễ",
      },
      {
        question: "Nguyên tắc 'Garbage in, garbage out' (GIGO) có nghĩa là:",
        options: [
          "Dữ liệu vào tốt thì kết quả tốt",
          "Dữ liệu rác vào thì kết quả rác ra - dấu hiệu của chương trình tồi",
          "Cần dọn dẹp bộ nhớ",
          "Cần xóa file tạm",
        ],
        correctAnswer: "Dữ liệu rác vào thì kết quả rác ra - dấu hiệu của chương trình tồi",
        difficulty: "Trung bình",
      },
      {
        question: "Assertion được sử dụng để:",
        options: [
          "Tăng tốc độ chương trình",
          "Ghi lại những giả thiết và loại bỏ điều kiện không mong đợi",
          "Giảm kích thước code",
          "Tạo giao diện đẹp",
        ],
        correctAnswer: "Ghi lại những giả thiết và loại bỏ điều kiện không mong đợi",
        difficulty: "Trung bình",
      },
      {
        question: "Khi nào nên ưu tiên tính chắc chắn hơn tính chính xác?",
        options: [
          "Không bao giờ",
          "Luôn luôn",
          "Khi chương trình luôn chạy thông tốt hơn là bị shutdown",
          "Chỉ khi có lỗi nghiêm trọng",
        ],
        correctAnswer: "Khi chương trình luôn chạy thông tốt hơn là bị shutdown",
        difficulty: "Khó",
      },
      {
        question: "Điều kiện biên (Boundary conditions) cần được kiểm tra vì:",
        options: [
          "Hầu hết các lỗi đều xảy ra ở các điều kiện biên",
          "Để tăng tốc độ chương trình",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Hầu hết các lỗi đều xảy ra ở các điều kiện biên",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần kiểm tra dữ liệu nhập?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để tránh lỗi và bảo vệ chương trình khỏi dữ liệu không hợp lệ",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để tránh lỗi và bảo vệ chương trình khỏi dữ liệu không hợp lệ",
        difficulty: "Trung bình",
      },
      {
        question: "Exception handling được sử dụng để làm gì?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để xử lý các lỗi và ngoại lệ trong quá trình chạy",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để xử lý các lỗi và ngoại lệ trong quá trình chạy",
        difficulty: "Trung bình",
      },
      {
        question: "Logging được sử dụng để làm gì?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để ghi lại các sự kiện và lỗi trong quá trình chạy",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để ghi lại các sự kiện và lỗi trong quá trình chạy",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần sử dụng assertion?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để kiểm tra các điều kiện và giả định trong code",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để kiểm tra các điều kiện và giả định trong code",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần kiểm tra giá trị trả về của hàm?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để đảm bảo hàm chạy đúng và không trả về giá trị lỗi",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để đảm bảo hàm chạy đúng và không trả về giá trị lỗi",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần kiểm tra điều kiện biên?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để đảm bảo chương trình chạy đúng với các giá trị giới hạn",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để đảm bảo chương trình chạy đúng với các giá trị giới hạn",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần sử dụng code review?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để tìm ra lỗi và cải thiện chất lượng code",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để tìm ra lỗi và cải thiện chất lượng code",
        difficulty: "Trung bình",
      },
    ],
  },
  {
    id: 9,
    title: "Gỡ lỗi và kiểm thử",
    description: "Kỹ thuật gỡ lỗi và các phương pháp kiểm thử",
    topics: ["Gỡ lỗi (Debug)", "Kiểm thử (Testing)"],
    questions: [
      {
        question: "Gỡ rối (Debug) là gì?",
        options: [
          "Viết code mới",
          "Các công việc cần làm để làm cho chương trình dịch thông, chạy thông",
          "Thiết kế giao diện",
          "Tối ưu hóa hiệu năng",
        ],
        correctAnswer: "Các công việc cần làm để làm cho chương trình dịch thông, chạy thông",
        difficulty: "Dễ",
      },
      {
        question: "Khi gỡ lỗi, điều quan trọng nhất là:",
        options: [
          "Thay đổi code ngay lập tức",
          "Hiểu vấn đề xuất phát từ đâu thì mới giải quyết được",
          "Viết lại toàn bộ chương trình",
          "Tăng tốc độ CPU",
        ],
        correctAnswer: "Hiểu vấn đề xuất phát từ đâu thì mới giải quyết được",
        difficulty: "Trung bình",
      },
      {
        question: "Kiểm thử (Testing) có mục đích là:",
        options: [
          "Chứng minh chương trình đúng",
          "Tìm ra lỗi trong chương trình",
          "Tăng tốc độ chương trình",
          "Giảm kích thước chương trình",
        ],
        correctAnswer: "Tìm ra lỗi trong chương trình",
        difficulty: "Trung bình",
      },
      {
        question: "Kiểm thử hộp đen (Black-box testing) là:",
        options: [
          "Testing dựa trên cấu trúc bên trong",
          "Testing chỉ dựa trên yêu cầu và đặc tả, không biết cấu trúc bên trong",
          "Testing chỉ cho lập trình viên",
          "Testing tự động",
        ],
        correctAnswer: "Testing chỉ dựa trên yêu cầu và đặc tả, không biết cấu trúc bên trong",
        difficulty: "Trung bình",
      },
      {
        question: "Kiểm thử biên (Boundary testing) tập trung vào:",
        options: [
          "Kiểm tra tất cả các trường hợp",
          "Sử dụng các giá trị ở trên hoặc dưới miền giới hạn",
          "Kiểm tra ngẫu nhiên",
          "Chỉ kiểm tra trường hợp bình thường",
        ],
        correctAnswer: "Sử dụng các giá trị ở trên hoặc dưới miền giới hạn",
        difficulty: "Khó",
      },
      {
        question: "Debugging heuristic 'Divide and conquer' có nghĩa là:",
        options: [
          "Chia nhỏ vấn đề để dễ tìm lỗi",
          "Tăng số lượng lập trình viên",
          "Viết nhiều hàm nhỏ",
          "Sử dụng nhiều file",
        ],
        correctAnswer: "Chia nhỏ vấn đề để dễ tìm lỗi",
        difficulty: "Trung bình",
      },
      {
        question: "Tại sao cần gỡ lỗi (debug)?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để tìm và sửa lỗi trong chương trình",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để tìm và sửa lỗi trong chương trình",
        difficulty: "Trung bình",
      },
      {
        question: "Breakpoint được sử dụng để làm gì?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để dừng chương trình tại một điểm cụ thể để kiểm tra",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để dừng chương trình tại một điểm cụ thể để kiểm tra",
        difficulty: "Trung bình",
      },
      {
        question: "Watch window được sử dụng để làm gì?",
        options: [
          "Để tăng tốc độ chương trình",
          "Để theo dõi giá trị của biến trong quá trình chạy",
          "Để giảm kích thước code",
          "Để tạo giao diện đẹp",
        ],
        correctAnswer: "Để theo dõi giá trị của biến trong quá trình chạy",
        difficulty: "Trung bình",
      },
      {
        question: "Unit testing là gì?",
        options: [
          "Testing toàn bộ chương trình",
          "Testing từng module hoặc hàm",
          "Testing giao diện người dùng",
          "Testing hiệu năng",
        ],
        correctAnswer: "Testing từng module hoặc hàm",
        difficulty: "Trung bình",
      },
      {
        question: "Integration testing là gì?",
        options: [
          "Testing từng module hoặc hàm",
          "Testing sự tương tác giữa các module",
          "Testing giao diện người dùng",
          "Testing hiệu năng",
        ],
        correctAnswer: "Testing sự tương tác giữa các module",
        difficulty: "Trung bình",
      },
      {
        question: "System testing là gì?",
        options: [
          "Testing từng module hoặc hàm",
          "Testing sự tương tác giữa các module",
          "Testing toàn bộ hệ thống",
          "Testing hiệu năng",
        ],
        correctAnswer: "Testing toàn bộ hệ thống",
        difficulty: "Trung bình",
      },
      {
        question: "Regression testing là gì?",
        options: [
          "Testing từng module hoặc hàm",
          "Testing sự tương tác giữa các module",
          "Testing lại sau khi sửa lỗi để đảm bảo không có lỗi mới",
          "Testing hiệu năng",
        ],
        correctAnswer: "Testing lại sau khi sửa lỗi để đảm bảo không có lỗi mới",
        difficulty: "Trung bình",
      },
    ],
  },
]
